<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>art_DEM &mdash; MTE 1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../index.html">
            
              <img src="../_static/Logo2r2.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
   
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../governing_equations.html">Governing equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../computational_approach.html">Computational approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parameters.html">Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../flanksim.html">Synthetic topopography: flank simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../artdem.html">Artificial DEM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../etna.html">Case study: Mount Etna</a></li>
<li class="toctree-l1"><a class="reference internal" href="../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ref.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app1.html">Complete derivation of the equations</a></li>
</ul>

   <ul>
        <li class="toctree-l1"><a href= "../genindex.html"><strong>Index</strong></a></li>
   </ul>


        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MTE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">art_DEM</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for art_DEM</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>

<div class="viewcode-block" id="generate_fractal_map">
<a class="viewcode-back" href="../index.html#art_DEM.generate_fractal_map">[docs]</a>
<span class="k">def</span> <span class="nf">generate_fractal_map</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a square fractal map using the diamond-square algorithm, followed by Gaussian filtering.</span>

<span class="sd">    The diamond-square algorithm is a fractal method used to generate random landscapes or textures.</span>
<span class="sd">    The algorithm works by dividing the map into squares and diamonds, then randomly displacing the midpoint</span>
<span class="sd">    of each to create roughness. Gaussian filtering is applied at the end to smooth out the map for a more</span>
<span class="sd">    natural look.</span>

<span class="sd">    :param size: Determines the size of the map which will be `(2^size) + 1`.</span>
<span class="sd">    :type size: scalar(int)</span>
<span class="sd">    :param roughness: The initial roughness factor for the diamond-square algorithm.</span>
<span class="sd">    :type roughness: scalar(float)</span>
<span class="sd">    :param sigma: Standard deviation for Gaussian filter, affecting the smoothness.</span>
<span class="sd">    :type sigma: scalar(float)</span>
<span class="sd">    :param seed: Optional seed for the random number generator.</span>
<span class="sd">    :type seed: (optional(scalar(int)))</span>

<span class="sd">    :return: **dem** *(array_like(float))* - A 2D numpy array representing the fractal map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Print out the parameters for the map generation</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;size art DEM (2^n-1 nodes): </span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;roughness art DEM: </span><span class="si">{</span><span class="n">roughness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter sigma: </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">diamond_square</span><span class="p">(</span><span class="n">map_</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">roughness</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the diamond square procedure on a map to generate terrain elevation.</span>

<span class="sd">        The function takes a 2D numpy array representing an elevation map, a step size, and a roughness factor.</span>
<span class="sd">        It updates the map in place, adding randomness to create a fractal pattern.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        :param map_: The elevation map, a 2D numpy array that is modified in place.</span>
<span class="sd">        :type map_: array_like(float)</span>
<span class="sd">        :param stepsize: The size of the square or diamond step in the algorithm. It determines the distance between points that will be updated.</span>
<span class="sd">        :type stepsize: scalar(int)</span>
<span class="sd">        :param roughness: A roughness factor determining the range of random values added to the midpoints.</span>
<span class="sd">        :type roughness: scalar(float)</span>

<span class="sd">        :return: None: The function modifies the input array `map_` in place and has no return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Calculate half of the stepsize, which will be used to offset coordinates</span>
        <span class="n">half_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stepsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Perform the diamond step</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">),</span> <span class="n">stepsize</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">stepsize</span><span class="p">):</span>
                <span class="c1"># Calculate the average of the corners of the square</span>
                <span class="n">square_averages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">][</span><span class="n">x</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">][</span><span class="n">x</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Set the middle of the square to average plus some randomness based on roughness</span>
                <span class="n">map_</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">square_averages</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">roughness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)</span>

        <span class="c1"># Perform the square step</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">),</span> <span class="n">half_step</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">y</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">)</span> <span class="o">%</span> <span class="n">stepsize</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">stepsize</span><span class="p">):</span>
                <span class="c1"># Calculate the average of the points of the diamond</span>
                <span class="c1">#  (considering wrap-around for edges)</span>
                <span class="n">diamond_averages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[(</span><span class="n">y</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">)][</span><span class="n">x</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[(</span><span class="n">y</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">)][</span><span class="n">x</span><span class="p">],</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span><span class="p">][(</span><span class="n">x</span> <span class="o">-</span> <span class="n">half_step</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                        <span class="n">map_</span><span class="p">[</span><span class="n">y</span><span class="p">][(</span><span class="n">x</span> <span class="o">+</span> <span class="n">half_step</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Only update the point if it is within the bounds of the map</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># Set the diamond point to the average plus some randomness based on roughness</span>
                    <span class="n">map_</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">diamond_averages</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">roughness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)</span>

    <span class="c1"># Set the random seed if provided for reproducibility</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;random seed: </span><span class="si">{</span><span class="n">seed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate the actual size of the map</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Initialize the map with zeros and set the corner values with initial roughness</span>
    <span class="n">map_</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    <span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
        <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">roughness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)</span>

    <span class="c1"># Set the initial step size to the size of the map minus one</span>
    <span class="n">stepsize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># A flag for determining how to decrease roughness, can be toggled for different effects</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Loop through the diamond-square steps to create terrain until the step size is small enough</span>
    <span class="k">while</span> <span class="n">stepsize</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Apply the diamond-square algorithm with current step size and roughness</span>

        <span class="n">diamond_square</span><span class="p">(</span><span class="n">map_</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)</span>
        <span class="c1"># Decrease the step size for the next iteration</span>
        <span class="n">stepsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stepsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Decrease roughness as the features become smaller, this can be linear or exponential</span>
        <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
           <span class="n">roughness</span> <span class="o">*=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">roughness</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">stepsize</span><span class="p">)</span>

    <span class="c1"># Once the fractal generation is complete, apply a Gaussian filter to smooth the map</span>
    <span class="n">map_</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">map_</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">map_</span></div>


<span class="c1">###################################################################################################</span>


<div class="viewcode-block" id="write_dem_to_ascii">
<a class="viewcode-back" href="../index.html#art_DEM.write_dem_to_ascii">[docs]</a>
<span class="k">def</span> <span class="nf">write_dem_to_ascii</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">cellsize</span><span class="p">,</span> <span class="n">xllcorner</span><span class="p">,</span> <span class="n">yllcorner</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;art_dem.ascii&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes the digital elevation model (DEM) data to an ASCII file in grid format.</span>

<span class="sd">    The ASCII format is a simple text-based format for storing raster data which is widely used in GIS</span>
<span class="sd">    software. Each line contains the data for a single row of the grid, with values separated by spaces.</span>

<span class="sd">    :param dem: 2D array containing elevation data.</span>
<span class="sd">    :type dem: array_like(float)</span>
<span class="sd">    :param ncol: Number of columns in the DEM grid.</span>
<span class="sd">    :type ncol: scalar(int)</span>
<span class="sd">    :param nrow: Number of rows in the DEM grid.</span>
<span class="sd">    :type ncol: scalar(int)</span>
<span class="sd">    :param cellsize: Size of each cell in the grid.</span>
<span class="sd">    :type cellsize: scalar(float)</span>
<span class="sd">    :param xllcorner: The western x-coordinate of the lower left corner of the DEM grid.</span>
<span class="sd">    :type xllcorner: scalar(float)</span>
<span class="sd">    :param yllcorner: The southern y-coordinate of the lower left corner of the DEM grid.</span>
<span class="sd">    :type yllcorner: scalar(float)</span>
<span class="sd">    :param filename: The name of the ASCII file to write.</span>
<span class="sd">    :type filename: string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Open file to write in</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Write all information as header</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ncols         </span><span class="si">{</span><span class="n">ncol</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nrows         </span><span class="si">{</span><span class="n">nrow</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;xllcorner     </span><span class="si">{</span><span class="n">xllcorner</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;yllcorner     </span><span class="si">{</span><span class="n">yllcorner</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cellsize      </span><span class="si">{</span><span class="n">cellsize</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;NODATA_value  -9999</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Write DEM</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dem</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="c1">###################################################################################################</span>


<div class="viewcode-block" id="generate_pathfile">
<a class="viewcode-back" href="../index.html#art_DEM.generate_pathfile">[docs]</a>
<span class="k">def</span> <span class="nf">generate_pathfile</span><span class="p">(</span><span class="n">xllcorner</span><span class="p">,</span> <span class="n">yllcorner</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">rough_length</span><span class="p">,</span> <span class="n">npath</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>\
                       <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;art_path.txt&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a path file for artifical data sampling paths in an ASCII format.</span>

<span class="sd">    :param xllcorner: The western x-coordinate of the lower left corner of the grid.</span>
<span class="sd">    :type xllcorner: scalar(float)</span>
<span class="sd">    :param yllcorner: The southern y-coordinate of the lower left corner of the grid.</span>
<span class="sd">    :type yllcorner: scalar(float)</span>
<span class="sd">    :param Lx: The length of the domain along the x-axis.</span>
<span class="sd">    :type Lx: scalar(float)</span>
<span class="sd">    :param rough_length: The rough length of the path, minor changes will happen through this function, so length is eventually different to passed length.</span>
<span class="sd">    :type rough_length: scalar(float)</span>
<span class="sd">    :param npath: Number of points in the path.</span>
<span class="sd">    :type npath: scalar(int)</span>
<span class="sd">    :param seed: Optional seed for the random number generator.</span>
<span class="sd">    :type seed: scalar(int)</span>
<span class="sd">    :param filename: The name of the text file to write the path coordinates.</span>
<span class="sd">    :type filename: string</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Set the random seed if provided for reproducibility</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
       <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
       <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;random seed: </span><span class="si">{</span><span class="n">seed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Size of domain</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="n">Lx</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Calculate start and end coordinates for the path, adding some randomness</span>
    <span class="n">xstart</span> <span class="o">=</span> <span class="n">Lx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">rough_length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">xend</span> <span class="o">=</span> <span class="n">Lx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rough_length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">ystart</span> <span class="o">=</span> <span class="n">Ly</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">yend</span> <span class="o">=</span> <span class="n">Ly</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="c1"># Initialize arrays to hold the path coordinates and the measurement of distance along the path</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npath</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dmeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npath</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">xpath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npath</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">ypath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npath</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Loop to calculate the path coordinates and cumulative distance</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npath</span><span class="p">):</span>
        <span class="c1"># Calculate the current point coordinates</span>
        <span class="n">xm</span> <span class="o">=</span> <span class="n">xstart</span> <span class="o">+</span> <span class="p">(</span><span class="n">xend</span> <span class="o">-</span> <span class="n">xstart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">npath</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">xllcorner</span>
        <span class="n">ym</span> <span class="o">=</span> <span class="n">ystart</span> <span class="o">+</span> <span class="p">(</span><span class="n">yend</span> <span class="o">-</span> <span class="n">ystart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">npath</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">yllcorner</span>
        <span class="n">xpath</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xm</span>
        <span class="n">ypath</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ym</span>

        <span class="c1"># Calculate the cumulative distance for each point</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="n">dmeas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">dmeas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xpath</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xpath</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ypath</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ypath</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>\
              <span class="o">+</span> <span class="n">dmeas</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Store the point data in the path array</span>
        <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">,</span> <span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dmeas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Write the path data to a text file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<span class="c1">###################################################################################################</span>
<span class="c1"># In this section, any comments are on a new line outlined to the = sign, to avoid removal with sed</span>
<span class="c1"># statement in the run script.</span>
<span class="c1">###################################################################################################</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># avoids module running when imported (sphinx)</span>

   <span class="c1"># Parameters for generation</span>
   <span class="n">ncol</span> <span class="o">=</span> <span class="mi">127</span>
        <span class="c1"># must be a power of 2 minus 1: 2^n - 1, e.g., 3, 7, 15, 31, 63, 127, 255, 511, 1023 ...</span>
   <span class="n">nrow</span> <span class="o">=</span> <span class="mi">127</span>
        <span class="c1"># must be the same as ncol</span>

   <span class="n">cellsize</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="c1"># Change this value if you want a different cell size</span>
   <span class="n">afx</span> <span class="o">=</span> <span class="mi">5</span>
       <span class="c1"># angle of flank in x-direction</span>
   <span class="n">afy</span> <span class="o">=</span> <span class="mi">12</span>
       <span class="c1"># angle &quot;&quot;</span>
   <span class="n">xllcorner</span> <span class="o">=</span> <span class="mi">50</span>
             <span class="c1"># x-coordinate of the lower left corner (most south-western node)</span>
   <span class="n">yllcorner</span> <span class="o">=</span> <span class="mi">100</span>
             <span class="c1"># y-coordinate of &quot;&quot;</span>
   <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="c1"># sigma for Gaussian filter</span>
   <span class="c1">#seed = 546  # if seed is chosen, make sure to uncomment related lines below (including seed)</span>

   <span class="c1"># Test if ncol != nrow, or not right size (see above)</span>
   <span class="k">if</span> <span class="n">ncol</span> <span class="o">!=</span> <span class="n">nrow</span> <span class="ow">or</span> <span class="p">((</span><span class="n">ncol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incompatible array size: </span><span class="si">{</span><span class="n">ncol</span><span class="p">,</span><span class="n">nrow</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

   <span class="c1"># A flag for either combining a rougher and a more detailed DEM into one (more realistic), or not</span>
   <span class="c1"># combine simply generates one DEM from two separate calls of the function to generate.</span>
   <span class="n">combine</span> <span class="o">=</span> <span class="kc">True</span>

   <span class="c1"># Printing the chosen parameters</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cellsize: </span><span class="si">{</span><span class="n">cellsize</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;angle flanks in x,y-direction (afx, afy): </span><span class="si">{</span><span class="n">afx</span><span class="p">,</span><span class="w"> </span><span class="n">afy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lower left corner x,y-coordinates (xllcorner, yllcorner): </span><span class="si">{</span><span class="n">xllcorner</span><span class="p">,</span><span class="w"> </span><span class="n">yllcorner</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

   <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
      <span class="n">roughness1</span> <span class="o">=</span> <span class="mi">20</span>
                 <span class="c1"># can be adjusted for desired level of detail</span>
      <span class="n">roughness2</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="n">dem1</span> <span class="o">=</span> <span class="n">generate_fractal_map</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roughness1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
      <span class="n">dem2</span> <span class="o">=</span> <span class="n">generate_fractal_map</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roughness2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
      <span class="n">dem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dem1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dem2</span><span class="p">)</span>  <span class="c1"># adding two DEMS</span>
      <span class="c1">#dem1 = generate_fractal_map(int(ncol).bit_length()-1+1, roughness1, sigma, seed)</span>
      <span class="c1">#dem2 = generate_fractal_map(int(ncol).bit_length()-1+1, roughness2, sigma, seed)</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">roughness</span> <span class="o">=</span> <span class="mi">12</span>
                <span class="c1"># can be adjusted for desired level of detail</span>
      <span class="n">dem</span> <span class="o">=</span> <span class="n">generate_fractal_map</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
      <span class="c1">#dem = generate_fractal_map(int(ncol).bit_length() - 1 + 1, roughness, sigma, seed)</span>


   <span class="c1"># Make the DEM sloped</span>
   <span class="n">av_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dem</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dem</span><span class="p">)):</span>
       <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">])):</span>
           <span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="n">av_val</span>
           <span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cellsize</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">afy</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="n">yllcorner</span>
                                       <span class="c1"># add the y slope adjustment</span>
           <span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cellsize</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">afx</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="n">xllcorner</span>
                                       <span class="c1"># add the x slope adjustment</span>
           <span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dem</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># decreases the DEM size (faster to read)</span>

   <span class="n">write_dem_to_ascii</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">cellsize</span><span class="p">,</span> <span class="n">xllcorner</span><span class="p">,</span> <span class="n">yllcorner</span><span class="p">)</span>

   <span class="c1"># Parameters for the path</span>
   <span class="n">rough_length</span> <span class="o">=</span> <span class="mi">30</span>
                <span class="c1"># this value determines the length of the path, however, the exact length</span>
                <span class="c1"># might differ, since random values are used to shift path points.</span>
   <span class="n">npath</span> <span class="o">=</span> <span class="mi">30</span>
         <span class="c1"># amount of observations points on the path</span>

   <span class="c1"># Printing the chosen parameters</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;~ length of the path: </span><span class="si">{</span><span class="n">rough_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;amount of observation points on the path: </span><span class="si">{</span><span class="n">npath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

   <span class="n">generate_pathfile</span><span class="p">(</span><span class="n">xllcorner</span><span class="p">,</span> <span class="n">yllcorner</span><span class="p">,</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cellsize</span><span class="p">,</span> <span class="n">rough_length</span><span class="p">,</span> <span class="n">npath</span><span class="p">)</span>
   <span class="c1">#generate_pathfile(xllcorner, yllcorner, (ncol - 1) * cellsize, rough_length, npath, seed)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, A.E. Hendrickx.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<style type="text/css">
  .scrollToTop {
    text-align: center;
    font-weight: bold;
    position: fixed;
    bottom: 60px;
    right: 40px;
    display: none;
  }
</style>
<a href="#" class="scrollToTop">Scroll To Top</a>
<script type="text/javascript">
  $(document).ready(function () {
    //Check to see if the window is top if not then display button
    $(window).scroll(function () {
      if ($(this).scrollTop() > 200) {
        $(".scrollToTop").fadeIn();
      } else {
        $(".scrollToTop").fadeOut();
      }
    });

    //Click event to scroll to top
    $(".scrollToTop").click(function () {
      $("html, body").animate(
        {
          scrollTop: 0,
        },
        500,
      );
      return false;
    });
  });
</script>

<style>
  /* Sidebar header (and topbar for mobile) */
  .wy-side-nav-search,
  .wy-nav-top {
    background: #3ae23a;
  }
  /* Sidebar */
  .wy-nav-side {
    background: #0c3303;
  }
</style>


</body>
</html>