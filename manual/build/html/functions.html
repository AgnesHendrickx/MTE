<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Functions &mdash; MTE 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=f2a433a1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References" href="ref.html" />
    <link rel="prev" title="Case study: Mount Etna" href="etna.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="index.html">
            
              <img src="_static/Logo2r2.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
   
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="governing_equations.html">Governing equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="computational_approach.html">Computational approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameters.html">Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="flanksim.html">Synthetic topopography: flank simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="artdem.html">Artificial DEM</a></li>
<li class="toctree-l1"><a class="reference internal" href="etna.html">Case study: Mount Etna</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-support">Support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#support.add_referencefield"><code class="docutils literal notranslate"><span class="pre">add_referencefield()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#support.compute_analytical_solution"><code class="docutils literal notranslate"><span class="pre">compute_analytical_solution()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#support.is_point_near_diagonal"><code class="docutils literal notranslate"><span class="pre">is_point_near_diagonal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#support.read_header"><code class="docutils literal notranslate"><span class="pre">read_header()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#support.shift_observation_points_edge"><code class="docutils literal notranslate"><span class="pre">shift_observation_points_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#support.topography"><code class="docutils literal notranslate"><span class="pre">topography()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-tools">Visualization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_line_measurements"><code class="docutils literal notranslate"><span class="pre">export_line_measurements()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_mesh_1D"><code class="docutils literal notranslate"><span class="pre">export_mesh_1D()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_mesh_2D"><code class="docutils literal notranslate"><span class="pre">export_mesh_2D()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_mesh_3D"><code class="docutils literal notranslate"><span class="pre">export_mesh_3D()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_plane_measurements"><code class="docutils literal notranslate"><span class="pre">export_plane_measurements()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools.export_spiral_measurements"><code class="docutils literal notranslate"><span class="pre">export_spiral_measurements()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-magnetostatics">Magnetostatics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.NNN"><code class="docutils literal notranslate"><span class="pre">NNN()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.compute_B_quadrature"><code class="docutils literal notranslate"><span class="pre">compute_B_quadrature()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.compute_B_surface_integral_cuboid"><code class="docutils literal notranslate"><span class="pre">compute_B_surface_integral_cuboid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.compute_B_surface_integral_wtopo"><code class="docutils literal notranslate"><span class="pre">compute_B_surface_integral_wtopo()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.compute_B_surface_integral_wtopo_noise"><code class="docutils literal notranslate"><span class="pre">compute_B_surface_integral_wtopo_noise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.cross"><code class="docutils literal notranslate"><span class="pre">cross()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.dNNNdr"><code class="docutils literal notranslate"><span class="pre">dNNNdr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.dNNNds"><code class="docutils literal notranslate"><span class="pre">dNNNds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.dNNNdt"><code class="docutils literal notranslate"><span class="pre">dNNNdt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.facmag"><code class="docutils literal notranslate"><span class="pre">facmag()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.line"><code class="docutils literal notranslate"><span class="pre">line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.plane"><code class="docutils literal notranslate"><span class="pre">plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.qcoords_1D"><code class="docutils literal notranslate"><span class="pre">qcoords_1D()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.qweights_1D"><code class="docutils literal notranslate"><span class="pre">qweights_1D()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#magnetostatics.rot"><code class="docutils literal notranslate"><span class="pre">rot()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-set_measurement_parameters">Set measurement parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#set_measurement_parameters.set_measurement_parameters"><code class="docutils literal notranslate"><span class="pre">set_measurement_parameters()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-art_DEM">Artificial DEM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#art_DEM.generate_fractal_map"><code class="docutils literal notranslate"><span class="pre">generate_fractal_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#art_DEM.generate_pathfile"><code class="docutils literal notranslate"><span class="pre">generate_pathfile()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#art_DEM.write_dem_to_ascii"><code class="docutils literal notranslate"><span class="pre">write_dem_to_ascii()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ref.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="app1.html">Complete derivation of the equations</a></li>
</ul>

   <p class="caption">
    <span class="caption-text">Indices</span>
   </p>
   <ul>
        <li class="toctree-l1"><a href= "genindex.html"><strong>Full index</strong></a></li>
        <li class="toctree-l1"><a href= "py-modindex.html"><strong>Modules</strong></a></li>
   </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MTE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h1>
<section id="module-support">
<span id="support"></span><h2>Support<a class="headerlink" href="#module-support" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="support.add_referencefield">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">add_referencefield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B0_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_si</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">benchmark</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#add_referencefield"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.add_referencefield" title="Link to this definition"></a></dt>
<dd><p>This function returns total computed magnetic field, along with its intensity, inclination
and declination at all points on a specified path using the following steps:,</p>
<ol class="arabic simple">
<li><p>Rotating the vector from the model’s coordinate system to align with the paleomagnetism coordinate system.</p></li>
<li><p>Incorporating a (global) reference field, denoted as B0.</p></li>
<li><p>Applying standard paleomagnetic equations for calculation as referenced in <span id="id1">[<a class="reference internal" href="ref.html#id20" title="Lisa Tauxe. Essentials of paleomagnetism. Univ of California Press, 2010.">Tauxe, 2010</a>]</span>.</p></li>
</ol>
<p>Subsequently, the function outputs the individual (x,y,z) components of the total magnetic field, as well as the calculated intensity, inclination, and declination values. These results are saved into a file titled: <code class="docutils literal notranslate"><span class="pre">measurements_path_refField{BO_name}.ascii</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>B0_name</strong> (<em>str</em>) – name of reference field (used in writing file).</p></li>
<li><p><strong>npath</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – amount of points on path.</p></li>
<li><p><strong>dmeas</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing distance between two points of the path (from meyer), used for plotting.</p></li>
<li><p><strong>B0</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(3) containing 3 components (0=x;1=y;2=z), components of reference field to be added.</p></li>
<li><p><strong>B_si</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,npath), containing components (0=x;1=y;2=z,npath) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each point of the path.</p></li>
<li><p><strong>benchmark</strong> (<em>str</em>) – number associated with benchmark, see <a class="reference internal" href="benchmarks.html"><span class="doc">Benchmarks</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B_siB0</strong> <em>(array_like(float))</em> - 2D array(3,npath), containing components (0=x;1=y;2=z,npath) of the total magnetic field (anomalous + reference field) at each point of the path.</p></li>
<li><p><strong>In_siB0</strong> <em>(array_like(float))</em> - 1D array(npath), containing intensity of the total magnetic field (anomalous + reference field) at each point of the path.</p></li>
<li><p><strong>Ic_siB0</strong> <em>(array_like(float))</em> - 1D array(npath), containing inclination of the total magnetic field (anomalous + reference field) at each point of the path.</p></li>
<li><p><strong>Dc_siB0</strong> <em>(array_like(float))</em> - 1D array(npath), containing declination of total magnetic field (anomalous + reference field) at each point of the path.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="support.compute_analytical_solution">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">compute_analytical_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xcenter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ycenter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zcenter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">benchmark</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#compute_analytical_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.compute_analytical_solution" title="Link to this definition"></a></dt>
<dd><p>Returns analytical solution, see <a class="reference internal" href="benchmarks.html"><span class="doc">Benchmarks</span></a>, of the components of the magnetic field for each benchmark.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing x coordinate of each computation point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing y coordinate of each computation point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing z coordinate of each computation point.</p></li>
<li><p><strong>R</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – radius of the sphere (if applicable)</p></li>
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization of magnetized body (constant).</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization of magnetized body (constant).</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization of magnetized body (constant).</p></li>
<li><p><strong>xcenter</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of center of the sphere.</p></li>
<li><p><strong>ycenter</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of center of the sphere.</p></li>
<li><p><strong>zcenter</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of center of the sphere.</p></li>
<li><p><strong>benchmark</strong> (<em>str</em>) – number associated with benchmark, see <a class="reference internal" href="benchmarks.html"><span class="doc">Benchmarks</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>h_fs</strong> <em>(array_like(float))</em> - 2D array(3,npath) containing components (0=x;1=y;2=z) produced by the analytical solution for the magnetic field for chosen benchmark (and model setup) and each point.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="support.is_point_near_diagonal">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">is_point_near_diagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#is_point_near_diagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.is_point_near_diagonal" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">This function checks if a point (x, y) is near to either of the two diagonals of a rectangle with sides of length Lx and Ly.</div>
<div class="line">Distance units are irrelevant but must be consistent.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x-coordinate of the observation point.</p></li>
<li><p><strong>y</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y-coordinate of the observation point.</p></li>
<li><p><strong>Lx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – length of the edge of a rectangle along the x-axis.</p></li>
<li><p><strong>Ly</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – length of the edge of a rectangle along the y-axis.</p></li>
<li><p><strong>eps</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – tolerance value for proximity check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>bool</strong> <em>(bool)</em> - True if (x, y) is near (&lt;eps) to either diagonal, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="support.read_header">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">read_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topo_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#read_header"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.read_header" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">This function checks if a DEM file has a header, and if so, reads in the values.</div>
<div class="line">These values are stored in dictionary {}. Header keys checked for: ncols, nrows, xllcorner, yllcorner, cellsize, and NODATA_value.</div>
<div class="line">This function works optimally when the header is in a standardized ASCII format.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>topo_file</strong> (<em>string</em>) – the opened (with read statement) “topofile”, containing the possible header to be read in.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>header</strong> <em>(array_like(string))</em> - dictionary containing values read in from header.</p></li>
<li><p><strong>statement</strong> <em>(bool))</em> - bool set to True if the full header was read in completely,              in case of an unexpected header term found or no header found, it is set to False.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="support.shift_observation_points_edge">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">shift_observation_points_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nely</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ym</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#shift_observation_points_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.shift_observation_points_edge" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">The original subroutine of <span id="id2">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>, was initially designed exclusively for use with the faces of a polyhedron. In contrast, our model s subdivides the top and bottom of the hexahedron elements into four triangles, see <a class="reference internal" href="#magnetostatics.compute_B_surface_integral_wtopo" title="magnetostatics.compute_B_surface_integral_wtopo"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnetostatics.compute_B_surface_integral_wtopo()</span></code></a>. This introduces additional singularities, and thus spatial issues, if the observation point <code class="docutils literal notranslate"><span class="pre">p</span></code> lies on the diagonal of the top or bottom face of an element.</div>
<div class="line">This function adjusts observation points positioned near the diagonal of additional triangles on the top (or bottom) of a hexahedron cell.</div>
<div class="line">This function uses <a class="reference internal" href="#support.is_point_near_diagonal" title="support.is_point_near_diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">support.is_point_near_diagonal()</span></code></a>, passing the length of an element in the x- and y-direction, and the x- and y- coordinates of each observation point with the x-coordinate and y-coordinate of each node on the top surface (see nnz-1) subtracted. This ensures testing of proximity to the diagonals of all elements. The function is designed to stop after first modification, as within macroscopic purposes we do not expect an observation point to be shifted to another diagonal. Afterwards, it states any modification within the “message”.</div>
<div class="line">Both x- and y-coordinates are shifted using a random value between -1 and 1 times the artificial distance (factor).</div>
<div class="line">This spatial problem isn’t restricted to the domain bounds. While generating an artificial distance for singularities within the main calculation function (<a class="reference internal" href="#magnetostatics.facmag" title="magnetostatics.facmag"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnetostatics.facmag()</span></code></a>) similar to the solution of <span id="id3">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>, <a class="reference internal" href="ref.html#id26" title="M. H. P. Bott. Two methods applicable to computers for evaluating magnetic anomalies due to finite three dimensional bodies. Geophysical Prospecting, 11(3):292-299, 1963. URL: https://www.earthdoc.org/content/journals/10.1111/j.1365-2478.1963.tb02039.x, doi:https://doi.org/10.1111/j.1365-2478.1963.tb02039.x.">Bott, 1963</a>]</span> for edge alignment, would be preferred. The problem emerges from our decision to utilize the <a class="reference internal" href="#magnetostatics.facmag" title="magnetostatics.facmag"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnetostatics.facmag()</span></code></a> in this particular manner (by subdividing the top and bottom into additional triangles). Since this setup is invoked via an external function, and because it falls outside the scope of the function’s original intention (to handle planes as polyhedron sides), we have opted to create this external function as well. Furthermore, there are several setups that do not require subdivision, and subsequently use the <a class="reference internal" href="#magnetostatics.compute_B_surface_integral_cuboid" title="magnetostatics.compute_B_surface_integral_cuboid"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnetostatics.compute_B_surface_integral_cuboid()</span></code></a>, hence shifting there could only potentially introduce inaccuracies. This is avoided by the introduction of this function, only called for in case function <a class="reference internal" href="#magnetostatics.compute_B_surface_integral_wtopo" title="magnetostatics.compute_B_surface_integral_wtopo"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnetostatics.compute_B_surface_integral_wtopo()</span></code></a> is employed, see <a class="reference internal" href="benchmarks.html"><span class="doc">Benchmarks</span></a>,:doc:<cite>flanksim</cite>,:doc:<cite>etna</cite>.</div>
</div>
<div class="line-block">
<div class="line">Benchmarks have established that the epsilon should be at least of a factor <strong>1e-5</strong> or larger. It is important to note that this value is not dynamically scaled and should be treated with careful consideration, particularly if there are any modifications to the core implementation of the model.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing the x-coordinate of each domain nodes.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing the y-coordinate of each domain nodes.</p></li>
<li><p><strong>Lx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – length of domain along the x-axis.</p></li>
<li><p><strong>Ly</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – length of domain along the y-axis.</p></li>
<li><p><strong>nelx</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – amount of elements (domain) in x-direction.</p></li>
<li><p><strong>nely</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – amount of elements (domain) in y-direction.</p></li>
<li><p><strong>nelz</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – amount of elements (domain) in z-direction.</p></li>
<li><p><strong>xm</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x-coordinate of the observation point.</p></li>
<li><p><strong>ym</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y-coordinate of the observation point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xm</strong> <em>(scalar(float))</em> - adjusted x coordinate of the observation point.</p></li>
<li><p><strong>ym</strong> <em>(scalar(float))</em> - adjusted x coordinate of the observation point.</p></li>
<li><p><strong>message</strong> <em>(str))</em> - message indicating any adjustments made to the observation point.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="support.topography">
<span class="sig-prename descclassname"><span class="pre">support.</span></span><span class="sig-name descname"><span class="pre">topography</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">llambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slopex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slopey</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/support.html#topography"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#support.topography" title="Link to this definition"></a></dt>
<dd><p>Returns topography (height) value at each point defined by x,y coordinates passed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of computation point.</p></li>
<li><p><strong>y</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of computation point.</p></li>
<li><p><strong>A</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – amplitude of sine function used to approximate wavy topography of ridges and gullies.</p></li>
<li><p><strong>llambda</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – wavelength of sine function used to approximate wavy topography of ridges and gullies.</p></li>
<li><p><strong>cos_dir</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – cosine of <code class="docutils literal notranslate"><span class="pre">direction</span></code>, that defines the direction of the wave function along the surface (default = perpendicular to slope).</p></li>
<li><p><strong>sin_dir</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – sine of <code class="docutils literal notranslate"><span class="pre">direction</span></code>, that defines the direction of the wave function along the surface (default = perpendicular to slope).</p></li>
<li><p><strong>slopex</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – the tangent of the angle (in rad) of the surface that defines the slope in x direction for each respective side.</p></li>
<li><p><strong>slopey</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – the tangent of the angle (in rad) of the surface that defines the slope in y direction for each respective side.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>h_fs</strong> <em>(scalar(float))</em> - the height value for the point passed to function for the respective position on the flank (chosen by <code class="docutils literal notranslate"><span class="pre">subbench</span></code>).</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-tools">
<span id="visualization"></span><h2>Visualization<a class="headerlink" href="#module-tools" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="tools.export_line_measurements">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_line_measurements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_vi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_si</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_th</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_line_measurements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_line_measurements" title="Link to this definition"></a></dt>
<dd><p>Export 1D line measurements to vtu file (plot with paraview), used for exporting line measurements with magnetic field strength (<strong>B</strong>) computed by analytical solution, surface integral or volume integral as vectors. If this function is used, but the volume integral is not used (default = not used, see <a class="reference internal" href="computational_approach.html"><span class="doc">Computational approach</span></a>), or a setup does not have an analytical solution (<a class="reference internal" href="flanksim.html#flanksim"><span class="std std-ref">flank simulations</span></a> and <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>), the values from surface integral computation are duplicated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of measurement points of the line or path.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing x coordinate of each measurement point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing y coordinate of each measurement point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing z coordinate of each measurement point.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>line_measurements.vtu</cite>)</p></li>
<li><p><strong>B_vi</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,NV), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by volume integral.</p></li>
<li><p><strong>B_si</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,N), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by surface integral.</p></li>
<li><p><strong>B_th</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,N), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by analytical solution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tools.export_mesh_1D">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_mesh_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">npath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ypath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_mesh_1D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_mesh_1D" title="Link to this definition"></a></dt>
<dd><p>Export 1D path to vtu file (plot with paraview), can be used in main visualize measurement path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>npath</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of measurement points of the line.</p></li>
<li><p><strong>xpath</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing x coordinate of each measurement point.</p></li>
<li><p><strong>ypath</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing y coordinate of each measurement point.</p></li>
<li><p><strong>zpath</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(npath) containing z coordinate of each measurement point.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>path.vtu</cite>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tools.export_mesh_2D">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_mesh_2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_mesh_2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_mesh_2D" title="Link to this definition"></a></dt>
<dd><p>This function creates a VTU file that represents a 2D mesh surface, which can be utilized for visualization in Paraview.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NV</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of points.</p></li>
<li><p><strong>nel</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of elements.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each point.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 2D array(4,nel), containing connectivity, marking points that define an element, see code.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>mesh_plane_measurements.vtu</cite>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tools.export_mesh_3D">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_mesh_3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nnx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nnz</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_mesh_3D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_mesh_3D" title="Link to this definition"></a></dt>
<dd><p>This function creates a VTU file that represents a 3D mesh with height data exported as point data and magnetization vectors exported as cell data.
The VTU file can be visualized using Paraview software.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NV</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of nodes.</p></li>
<li><p><strong>nel</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of elements.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each node.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each node.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each node.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 2D array(8,nel), containing connectivity, marking nodes that define an element, see code.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>mesh.vtu</cite>)</p></li>
<li><p><strong>Mx</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(nel) x component magnetization of each cell.</p></li>
<li><p><strong>My</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(nel) y component magnetization of each cell.</p></li>
<li><p><strong>Mz</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(nel) z component magnetization of each cell.</p></li>
<li><p><strong>nnx</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of nodes, x direction.</p></li>
<li><p><strong>nny</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of nodes, y direction.</p></li>
<li><p><strong>nnz</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of nodes, z direction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tools.export_plane_measurements">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_plane_measurements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_vi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_si</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_th</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_plane_measurements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_plane_measurements" title="Link to this definition"></a></dt>
<dd><p>Export 2D plane measurements to vtu file (plot with paraview), used for exporting plane measurements with magnetic field strength (<strong>B</strong>) computed by analytical solution, surface integral or volume integral as vectors. If this function is used, but the volume integral is not used (default = not used, see <a class="reference internal" href="computational_approach.html"><span class="doc">Computational approach</span></a>), or a setup does not have an analytical solution (<a class="reference internal" href="flanksim.html#flanksim"><span class="std std-ref">flank simulations</span></a> and <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>), the values from surface integral computation are duplicated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NV</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of measurement points of the plane.</p></li>
<li><p><strong>nel</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of elements of the measurement plane.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each measurement point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each measurement point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each measurement point.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 2D array(4,nel), containing connectivity, marking point that define an element, see code.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>plane_measurements.vtu</cite>)</p></li>
<li><p><strong>B_vi</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,NV), containing components (0=x;1=y;2=z,NV) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by volume integral.</p></li>
<li><p><strong>B_si</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,NV), containing components (0=x;1=y;2=z,NV) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by surface integral.</p></li>
<li><p><strong>B_th</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,NV), containing components (0=x;1=y;2=z,NV) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by analytical solution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tools.export_spiral_measurements">
<span class="sig-prename descclassname"><span class="pre">tools.</span></span><span class="sig-name descname"><span class="pre">export_spiral_measurements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_vi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_si</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_th</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tools.html#export_spiral_measurements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tools.export_spiral_measurements" title="Link to this definition"></a></dt>
<dd><p>Export 1D spiral measurements to vtu file (plot with paraview), used for exporting spiral measurements with magnetic field strength (<strong>B</strong>) computed by analytical solution, surface integral or volume integral as vectors. If this function is used, but the volume integral is not used (default = not used, see <a class="reference internal" href="computational_approach.html"><span class="doc">Computational approach</span></a>), or a setup does not have an analytical solution (<a class="reference internal" href="flanksim.html#flanksim"><span class="std std-ref">flank simulations</span></a> and <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>), the values from surface integral computation are duplicated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – number of measurement points of the spiral.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing x coordinate of each measurement point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing y coordinate of each measurement point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(N) containing z coordinate of each measurement point.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – the name of the output file (default: <cite>line_measurements.vtu</cite>)</p></li>
<li><p><strong>B_vi</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,N), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by volume integral.</p></li>
<li><p><strong>B_si</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,N), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by surface integral.</p></li>
<li><p><strong>B_th</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array(3,N), containing components (0=x;1=y;2=z,N) of the computed magnetic field due to the underlying magnetized matter (anomalous field) at each measurement point computed by analytical solution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-magnetostatics">
<span id="magnetostatics"></span><h2>Magnetostatics<a class="headerlink" href="#module-magnetostatics" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.NNN">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">NNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.NNN" title="Link to this definition"></a></dt>
<dd><p>{DESCRIPTION FUNCTION} Q1 basis functions inside the [-1:1]x[-1:1]x[-1:1] reference element</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – ** - 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>s</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>t</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>N</strong> <em>(array_like(float))</em> - 1D array(8) containing {DESCRIPTION RETURN PARAMETER}</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.compute_B_quadrature">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">compute_B_quadrature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nqdim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.compute_B_quadrature" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Solves volume integral, numerical solution, as the volume integral is parameterized by the number of quadrature points per dimension (nqdim). Computes magnetic field components based on 2^3 quadrature point integration produced by a single hexahedron (cuboid) carrying a magnetization vector (Mx,My,Mz) assumed to be constant inside the element. # TODO: allow for higher quadrature</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of observation point.</p></li>
<li><p><strong>ymeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of observation point.</p></li>
<li><p><strong>zmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of observation point.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each observation point.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each observation point.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each observation point.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 1D array(8), containing connectivity, marking nodes that define an element, see code.</p></li>
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization [A/m] of the element.</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization [A/m]  of the element.</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization [A/m] of the element.</p></li>
<li><p><strong>nqpts</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – the number of quadrature points per dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B_vi</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of the magnetic field strength [T] at a point computed by volume integral method.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.compute_B_surface_integral_cuboid">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">compute_B_surface_integral_cuboid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.compute_B_surface_integral_cuboid" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">This function computes the magnetic field at a point (defined my x,y,z-coordinate) produced by a cuboid element employing <a class="reference internal" href="#magnetostatics.facmag" title="magnetostatics.facmag"><code class="xref py py-func docutils literal notranslate"><span class="pre">facmag()</span></code></a> function on each face. Here again the magnetization vector (Mx,My,Mz) is assumed to be constant inside the element. It uses the <code class="docutils literal notranslate"><span class="pre">icon</span></code> array to identify the x-,y-,z-coordinates associated with each node, before calling <a class="reference internal" href="#magnetostatics.facmag" title="magnetostatics.facmag"><code class="xref py py-func docutils literal notranslate"><span class="pre">facmag()</span></code></a>, to compute the total magnetic field strength for each face.</div>
<div class="line">Magnetic field strength <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is computed in Tesla [T]. Note that the negative of the computed values is passed, as the numbering of our nodes was counterclockwise, not clockwise as in <span id="id4">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
<div class="line">Distance units are irrelevant but must be consistent.  For numbering of the nodes, see comments in code.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of observation point.</p></li>
<li><p><strong>ymeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of observation point.</p></li>
<li><p><strong>zmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of observation point.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each node.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each node.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each node.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 1D array(8), containing connectivity, marking nodes that define an element, see code.</p></li>
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization [A/m] of the element.</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization [A/m] of the element.</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization [A/m] of the element.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B_si</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of the magnetic field strength in [T] at each point computed by surface integral method for a cuboid element.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.compute_B_surface_integral_wtopo">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">compute_B_surface_integral_wtopo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.compute_B_surface_integral_wtopo" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">This function computes the magnetic field at a point (defined my x,y,z-coordinate) produced by a hexahedron element which vertical sides are planar. Only the top and bottom faces can contain 4 nodes which are not co-planar.</div>
<div class="line">In light thereof we subdivide the top and bottom faces into four triangles. This feature is needed in the case topography is prescribed at the top (or bottom) of the domain and the vertical position of the nodes are modified.</div>
<div class="line">It uses the <code class="docutils literal notranslate"><span class="pre">icon</span></code> array to identify the x-,y-,z-coordinates associated with each node, before calling <a class="reference internal" href="#magnetostatics.facmag" title="magnetostatics.facmag"><code class="xref py py-func docutils literal notranslate"><span class="pre">facmag()</span></code></a>, to compute the total magnetic field strength for each face and triangle.</div>
<div class="line">Magnetic field strength <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is computed in Tesla [T]. Note that the negative of the computed values is passed, as the numbering of our nodes was counterclockwise, not clockwise as in <span id="id5">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
<div class="line">Distance units are irrelevant but must be consistent. For numbering of the nodes, see comments in code.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of observation point.</p></li>
<li><p><strong>ymeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of observation point.</p></li>
<li><p><strong>zmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of observation point.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each node.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each node.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each node.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 1D array(8), containing connectivity, marking nodes that define an element, see code.</p></li>
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization [A/m] of the element.</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization [A/m] of the element.</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization [A/m] of the element.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B_si</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of the magnetic field strength in tesla [T] at a point computed by surface integral method for a cuboid element with topography on top and/or bottom surface.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.compute_B_surface_integral_wtopo_noise">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">compute_B_surface_integral_wtopo_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">icon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.compute_B_surface_integral_wtopo_noise" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">This function computes the magnetic field produced by a hexahedron element which vertical sides are planar. Only the top and bottom faces can contain 4 nodes which are not co-planar, and are therefor subdivided into four triangles.</div>
<div class="line">Numbering of nodes is same as previous function. The noise is added to the extra node on the top/bottom surface.</div>
<div class="line">Note that when computation are caried out and noise is added to this middle point, it could be that the observation point is then location within the domain, but we do not correct for it nor test it. So, this situation must be avoided during setup of any testing employing this function.</div>
<div class="line">Distance units are irrelevant but must be consistent.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of observation point.</p></li>
<li><p><strong>ymeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of observation point.</p></li>
<li><p><strong>zmeas</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of observation point.</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing x coordinate of each node.</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing y coordinate of each node.</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(NV) containing z coordinate of each node.</p></li>
<li><p><strong>icon</strong> (<em>array_like</em><em>(</em><em>int</em><em>)</em>) – 1D array(8), containing connectivity, marking nodes that define an element, see code.</p></li>
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization [A/m] of the element.</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization [A/m] of the element.</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization [A/m] of the element.</p></li>
<li><p><strong>noise</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – the height substracted or added to the middle node on the top and/or bottom surface of each element representing noise potentially smoothed by the DEM.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B_si</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of the magnetic field strength in [T] at a point computed by surface integral method for a cuboid element with topography on top and/or bottom surface and noise.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.cross">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.cross" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Produces vector (cross) product of two vectors. <span class="math notranslate nohighlight">\(\vec{a} \times \vec{b} = \vec{c}\)</span></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(3) containing 3 components (0=x;1=y;2=z) of vector <strong>a</strong>.</p></li>
<li><p><strong>b</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(3) containing 3 components (0=x;1=y;2=z) of vector <strong>b</strong>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>c</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of vector <strong>c</strong>..</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.dNNNdr">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">dNNNdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.dNNNdr" title="Link to this definition"></a></dt>
<dd><p>{DESCRIPTION FUNCTION}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – ** - 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>s</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>t</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dNdr</strong> <em>(array_like(float))</em> - 1D array(8) containing {DESCRIPTION RETURN PARAMETER}</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.dNNNds">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">dNNNds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.dNNNds" title="Link to this definition"></a></dt>
<dd><p>{DESCRIPTION FUNCTION}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – ** - 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>s</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>t</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dNds</strong> <em>(array_like(float))</em> - 1D array(8) containing {DESCRIPTION RETURN PARAMETER}</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.dNNNdt">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">dNNNdt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.dNNNdt" title="Link to this definition"></a></dt>
<dd><p>{DESCRIPTION FUNCTION}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – ** - 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>s</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
<li><p><strong>t</strong> (<em>(</em><em>array_like</em><em>(</em><em>float</em><em>)</em><em>)</em>) – 1D array(nqpts) containing {DESCRIPTION PARAMETER}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dNdt</strong> <em>(array_like(float))</em> - 1D array(8) containing {DESCRIPTION RETURN PARAMETER}</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.facmag">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">facmag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.facmag" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Function FACMAG computes the magnetic field strength <strong>B</strong> due to surface charge on a polygonal face. Repeated calls on each face of a polyhedron builds the field of said arbitrary polyhedron, algorithm from <span id="id6">[<a class="reference internal" href="ref.html#id26" title="M. H. P. Bott. Two methods applicable to computers for evaluating magnetic anomalies due to finite three dimensional bodies. Geophysical Prospecting, 11(3):292-299, 1963. URL: https://www.earthdoc.org/content/journals/10.1111/j.1365-2478.1963.tb02039.x, doi:https://doi.org/10.1111/j.1365-2478.1963.tb02039.x.">Bott, 1963</a>]</span>.</div>
<div class="line">The polygon is limited to 10 corners (n). Requires functions <a class="reference internal" href="#magnetostatics.rot" title="magnetostatics.rot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rot()</span></code></a>, <a class="reference internal" href="#magnetostatics.line" title="magnetostatics.line"><code class="xref py py-func docutils literal notranslate"><span class="pre">line()</span></code></a>, <a class="reference internal" href="#magnetostatics.plane" title="magnetostatics.plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">plane()</span></code></a> as define above. Distance units are irrelevant but must be consistent.</div>
<div class="line">A spatial problem, see <a class="reference internal" href="computational_approach.html"><span class="doc">Computational approach</span></a>, is mitigated due to the introduction of a small (1e-20) artificial distance for <code class="docutils literal notranslate"><span class="pre">p</span></code>, in case <code class="docutils literal notranslate"><span class="pre">p</span></code> lies on a plane aligning with an edge of an element.</div>
<div class="line">Directly translated from ANSI-standard FORTRAN 77 subroutines from <span id="id7">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component magnetization [A/m] of the element.</p></li>
<li><p><strong>My</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component magnetization [A/m] of the element.</p></li>
<li><p><strong>Mz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component magnetization [A/m] of the element.</p></li>
<li><p><strong>x0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of observation point (xmeas).</p></li>
<li><p><strong>y0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of observation point (ymeas).</p></li>
<li><p><strong>z0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of observation point (zmeas).</p></li>
<li><p><strong>x</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(n+1) containing x coordinate for each polygon corner (and wrapping around).</p></li>
<li><p><strong>y</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(n+1) containing y coordinate for each polygon corner (and wrapping around).</p></li>
<li><p><strong>z</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 1D array(n+1) containing z coordinate for each polygon corner (and wrapping around).</p></li>
<li><p><strong>n</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – amount of corners defining the polygon surface, max 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>B</strong> <em>(array_like(float))</em> - 1D array(3) containing 3 components (0=x;1=y;2=z) of the magnetic field strength [T] at a point due to the surface charges of a polygon surface.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.line">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.line" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Function LINE determines the intersection (x,y,z) of two lines.  First line is defined by points (x1,y1,z1) and (x2,y2,z2).</div>
<div class="line">Second line is perpendicular to the first and passes through point (x0,y0,z0).Distance between (x,y,z) and (x0,y0,z0) is returned as r. Computation is done by a transformation of coordinate systems, and defining two vectors T0 and T2 in the process. T0 = vector from point 1 (x1,y1,z1) to point 0 (x0,y0,z0). T2 = vector from point 1 (x1,y1,z1) to point 2 (x2,y2,z2).</div>
<div class="line">Directly translated from ANSI-standard FORTRAN 77 subroutines from <span id="id8">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 0.</p></li>
<li><p><strong>y0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 0.</p></li>
<li><p><strong>z0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 0.</p></li>
<li><p><strong>x1</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 1.</p></li>
<li><p><strong>y1</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 1.</p></li>
<li><p><strong>z1</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 1.</p></li>
<li><p><strong>x2</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 2.</p></li>
<li><p><strong>y2</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 2.</p></li>
<li><p><strong>z2</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> <em>(scalar(float))</em> - x coordinate of intersection point between the lines</p></li>
<li><p><strong>y</strong> <em>(scalar(float))</em> - y coordinate of intersection point between the lines</p></li>
<li><p><strong>z</strong> <em>(scalar(float))</em> - z coordinate of intersection point between the lines</p></li>
<li><p><strong>v1</strong> <em>(scalar(float))</em> - the negative of the projection of vector T0 on T2 (dot product of normalized T2 and T0).</p></li>
<li><p><strong>v2</strong> <em>(scalar(float))</em> - the length of vector T2 minus the projection of vector T0 on T2.</p></li>
<li><p><strong>r</strong> <em>(scalar(float))</em> - distance between intersection point and point 0 (x0,y0,z0)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.plane">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.plane" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Function plane computes the intersection (x,y,z) of a plane and a perpendicular line.</div>
<div class="line">The plane is defined by three points (x1,y1,z1), (x2,y2,z2), and (x3,y3,z3), in facmag the (first 3) polygon corners are passed. The line passes through (x0,y0,z0), in facmag the observation point is passed.</div>
<div class="line">Computation is done by a transformation and inverse transformation of coordinates systems. It defines three vectors N0, N2 and N3 in the process. N0 = vector from point 1 (x1,y1,z1) to point 0 (x0,y0,z0). N2 = vector from point 1 (x1,y1,z1) to point 2 (x2,y2,z2). N3 = vector from point 1 (x1,y1,z1) to point 3 (x3,y3,z3).</div>
<div class="line">Directly translated from ANSI-standard FORTRAN 77 subroutines from <span id="id9">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 0.</p></li>
<li><p><strong>y0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 0.</p></li>
<li><p><strong>z0</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 0.</p></li>
<li><p><strong>x1</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 1.</p></li>
<li><p><strong>y1</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 1.</p></li>
<li><p><strong>z1</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 1.</p></li>
<li><p><strong>x2</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 2.</p></li>
<li><p><strong>y2</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 2.</p></li>
<li><p><strong>z2</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 2.</p></li>
<li><p><strong>x3</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point 3.</p></li>
<li><p><strong>y3</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point 3.</p></li>
<li><p><strong>z3</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> <em>(scalar(float))</em> - x coordinate of the intersection point (plane and line)</p></li>
<li><p><strong>y</strong> <em>(scalar(float))</em> - y coordinate of the intersection point (plane and line)</p></li>
<li><p><strong>z</strong> <em>(scalar(float))</em> - z coordinate of the intersection point (plane and line)</p></li>
<li><p><strong>r</strong> <em>(scalar(float))</em> - distance between intersection point and point 0 (x0,y0,z0)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.qcoords_1D">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">qcoords_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nqpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.qcoords_1D" title="Link to this definition"></a></dt>
<dd><p>Determines the coordinates of the quadrature points depending on the amount chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nqpts</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – the number of quadrature points per dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>coordsq</strong> <em>(array_like(float))</em> - 1D array(nqpts) containing coordinates of quadrature points.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.qweights_1D">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">qweights_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nqpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.qweights_1D" title="Link to this definition"></a></dt>
<dd><p>Determines the weights of the quadrature points depending on the amount chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nqpts</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – the number of quadrature points per dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>weightsq</strong> <em>(array_like(float))</em> - 1D array(nqpts) containing weights of quadrature points.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="magnetostatics.rot">
<span class="sig-prename descclassname"><span class="pre">magnetostatics.</span></span><span class="sig-name descname"><span class="pre">rot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">az</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#magnetostatics.rot" title="Link to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Function ROT finds the sense of rotation of the vector from (ax,ay,az) to (bx,by,bz) with respect to a second vector through point (px,py,pz). The second vector has components given by (nx,ny,nz).</div>
<div class="line">Returned parameter s is 1 if anticlockwise, -1 if clockwise, or 0 if colinear.</div>
<div class="line">Directly translated from ANSI-standard FORTRAN 77 subroutines from <span id="id10">[<a class="reference internal" href="ref.html#id16" title="Richard J. Blakely. Potential Theory in Gravity and Magnetic Applications. Cambridge University Press, 1995. doi:10.1017/CBO9780511549816.006.">Blakely, 1995</a>]</span>.</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ax</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point a, defines start of the first vector.</p></li>
<li><p><strong>ay</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point a, defines start of the first vector.</p></li>
<li><p><strong>az</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point a, defines start of the first vector.</p></li>
<li><p><strong>bx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point b, defines end of the first vector.</p></li>
<li><p><strong>by</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point b, defines end of the first vector.</p></li>
<li><p><strong>bz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point b, defines end of the first vector.</p></li>
<li><p><strong>nx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x component of second vector.</p></li>
<li><p><strong>ny</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y component of second vector.</p></li>
<li><p><strong>nz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z component of second vector.</p></li>
<li><p><strong>px</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – x coordinate of point p, second vector passes through.</p></li>
<li><p><strong>py</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – y coordinate of point p, second vector passes through.</p></li>
<li><p><strong>pz</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – z coordinate of point p, second vector passes through.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>s</strong> <em>(scalar(int))</em> - parameter that defines sense of rotation of a vector w.r.t. a second vector</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-set_measurement_parameters">
<span id="set-measurement-parameters"></span><h2>Set measurement parameters<a class="headerlink" href="#module-set_measurement_parameters" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="set_measurement_parameters.set_measurement_parameters">
<span class="sig-prename descclassname"><span class="pre">set_measurement_parameters.</span></span><span class="sig-name descname"><span class="pre">set_measurement_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rDEM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sDEM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">site</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/set_measurement_parameters.html#set_measurement_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#set_measurement_parameters.set_measurement_parameters" title="Link to this definition"></a></dt>
<dd><p>Returns measurement parameters from <span id="id11">[<a class="reference internal" href="ref.html#id15" title="Romy Meyer and Lennart V. de Groot. Local magnetic anomalies in rugged volcanic terrain explain bias in paleomagnetic data: consequences for sampling. Geophysical Research Letters, 2023.">Meyer and de Groot, 2023</a>]</span> of the chosen (passed) parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rDEM</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – number associated with resolution of the DEM, see <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>.</p></li>
<li><p><strong>sDEM</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – number associated with size of the DEM, see <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>.</p></li>
<li><p><strong>site</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – number associated with resolution of the domain, see <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>.</p></li>
<li><p><strong>path</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – number associated with specific paths of a site, see <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>.</p></li>
<li><p><strong>ho</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – number associated with height option for the path, see <a class="reference internal" href="etna.html"><span class="doc">Case study: Mount Etna</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Range<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>rDEM</strong> - for all sites except site 3: either <code class="docutils literal notranslate"><span class="pre">2</span></code> meter or <code class="docutils literal notranslate"><span class="pre">5</span></code> meter, for site 3, only <code class="docutils literal notranslate"><span class="pre">2</span></code> meter available.</p></li>
<li><p><strong>sDEM</strong> - different for most sites/rDEM combinations.</p></li>
<li><p><strong>site</strong> - [1:6].</p></li>
<li><p><strong>path</strong> - for all sites except site 6: [1:3], for site 6, only <code class="docutils literal notranslate"><span class="pre">1</span></code> available.</p></li>
<li><p><strong>ho</strong> - for all sites except site 6: [1:2], where <code class="docutils literal notranslate"><span class="pre">1</span></code> relates to 1 meter above the surface and <code class="docutils literal notranslate"><span class="pre">2</span></code> relates to 1.8 meter above the surface. For site 6, only <code class="docutils literal notranslate"><span class="pre">1</span></code> available.</p></li>
<li><dl>
<dt>After DEM choice, for each site one can choose the path and height above the surface, options for each site are given in the last two columns, irrespective of DEM choice, all can be selected.</dt><dd><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>site</p></th>
<th class="head"><p>rDEM</p></th>
<th class="head"><p>sDEM</p></th>
<th class="head"><p>~size [m] <a class="footnote-reference brackets" href="#id16" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></th>
<th class="head"><p>path</p></th>
<th class="head" colspan="2"><p>ho (height)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>1</p></td>
<td><p>2100</p></td>
<td rowspan="12"><p>1-3</p></td>
<td colspan="2" rowspan="12"><p>1 (1m)</p>
<p>2 (1.8m)</p>
</td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>2</p></td>
<td><p>1500</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>3</p></td>
<td><p>1100</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>4</p></td>
<td><p>700</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>5</p></td>
<td><p>500</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>6</p></td>
<td><p>50 (0m around)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>7</p></td>
<td><p>4000</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2m</p></td>
<td><p>8</p></td>
<td><p>6000</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5m</p></td>
<td><p>1</p></td>
<td><p>2100</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>5m</p></td>
<td><p>2</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5m</p></td>
<td><p>3</p></td>
<td><p>200</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
<td rowspan="2"></td>
<td rowspan="2"><p><strong>2</strong></p></td>
<td rowspan="2"><p><strong>5</strong></p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2/5</p></td>
<td><p>2m</p></td>
<td><p>n/a</p></td>
<td><p>2100</p></td>
<td rowspan="5"><p>1-3</p></td>
<td rowspan="5"><p>1 (1m)</p>
<p>2 (1.8m)</p>
</td>
<td rowspan="5"><p>1 (25cm)</p>
<p>2 (75cm)</p>
<p>3 (125cm)</p>
<p>4 (175cm)</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2/5</p></td>
<td><p>5m</p></td>
<td><p>1</p></td>
<td><p>2100</p></td>
</tr>
<tr class="row-odd"><td><p>2/5</p></td>
<td><p>5m</p></td>
<td><p>2</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-even"><td><p>2/5</p></td>
<td><p>5m</p></td>
<td><p>3</p></td>
<td><p>200</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>2m</p></td>
<td><p>1</p></td>
<td><p>2100</p></td>
<td rowspan="3"><p>1-3</p></td>
<td colspan="2" rowspan="3"><p>1 (1m)</p>
<p>2 (1.8m)</p>
</td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>2m</p></td>
<td><p>2</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>2m</p></td>
<td><p>3</p></td>
<td><p>200</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>4/6</p></td>
<td><p>2m</p></td>
<td><p>n/a</p></td>
<td><p>2100</p></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>4/6</p></td>
<td><p>5m</p></td>
<td><p>1</p></td>
<td><p>2100</p></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>5m</p></td>
<td><p>2</p></td>
<td><p>200</p></td>
<td rowspan="2"><p>1-3</p></td>
<td colspan="2" rowspan="2"><p>1 (1m)</p>
<p>2 (1.8m)</p>
</td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>5m</p></td>
<td><p>3</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>2m</p></td>
<td><p>2</p></td>
<td><p>1100</p></td>
<td rowspan="5"><p>1</p></td>
<td colspan="2" rowspan="5"><p>1 (1m)</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>5m</p></td>
<td><p>3</p></td>
<td><p>500</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>5m</p></td>
<td><p>4</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>5m</p></td>
<td><p>5</p></td>
<td><p>200 (50m arnd)</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>5m</p></td>
<td><p>6</p></td>
<td><p>100 (20m arnd)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>Lx</strong> <em>(scalar(float))</em> - length of domain in x-direction in meters.</p></li>
<li><p><strong>Ly</strong> <em>(scalar(float))</em> - length of domain in y-direction in meters.</p></li>
<li><p><strong>Lz</strong> <em>(scalar(float))</em> - length of domain in x-direction in meters.</p></li>
<li><p><strong>nelx</strong> <em>(scalar(int))</em> - amount of elements in x-direction of domain.</p></li>
<li><p><strong>nely</strong> <em>(scalar(int))</em> - amount of elements in y-direction of domain.</p></li>
<li><p><strong>nelz</strong> <em>(scalar(int))</em> - amount of elements in z-direction of domain.</p></li>
<li><p><strong>xllcorner</strong> <em>(scalar(float))</em> - x-coordinate of the DEM cut corner, used to align domain with field measurement coordinates in (WGS84) UTM Easting (meters), zone 33N.</p></li>
<li><p><strong>yllcorner</strong> <em>(scalar(float))</em> - y-coordinate of the DEM cut corner, used to align domain with field measurement coordinates in (WGS84) UTM Northing (meters), zone 33N.</p></li>
<li><p><strong>npath</strong> <em>(scalar(int))</em> - amount of measurement points for the field path from <span id="id13">[<a class="reference internal" href="ref.html#id15" title="Romy Meyer and Lennart V. de Groot. Local magnetic anomalies in rugged volcanic terrain explain bias in paleomagnetic data: consequences for sampling. Geophysical Research Letters, 2023.">Meyer and de Groot, 2023</a>]</span>.</p></li>
<li><p><strong>zpath_height</strong> <em>(scalar(float))</em> - height of the field measurement path above the surface from <span id="id14">[<a class="reference internal" href="ref.html#id15" title="Romy Meyer and Lennart V. de Groot. Local magnetic anomalies in rugged volcanic terrain explain bias in paleomagnetic data: consequences for sampling. Geophysical Research Letters, 2023.">Meyer and de Groot, 2023</a>]</span> in meters.</p></li>
<li><p><strong>pathfile</strong> <em>(string)</em> - name of the file associated with the field path from <span id="id15">[<a class="reference internal" href="ref.html#id15" title="Romy Meyer and Lennart V. de Groot. Local magnetic anomalies in rugged volcanic terrain explain bias in paleomagnetic data: consequences for sampling. Geophysical Research Letters, 2023.">Meyer and de Groot, 2023</a>]</span>, containing all coordinates of measurement points and magnetic field strength measurement data (converted to UTM).</p></li>
<li><p><strong>pathfile</strong> <em>(string)</em> - name of the file associated with the DEM cut chosen.</p></li>
<li><p><strong>IGRFx</strong> <em>(scalar(float))</em> - x-component of the IGRF (global reference field) in Tesla.</p></li>
<li><p><strong>IGRFy</strong> <em>(scalar(float))</em> - y-component of the IGRF (global reference field) in Tesla.</p></li>
<li><p><strong>IGRFz</strong> <em>(scalar(float))</em> - z-component of the IGRF (global reference field) in Tesla.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-art_DEM">
<span id="artificial-dem"></span><h2>Artificial DEM<a class="headerlink" href="#module-art_DEM" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="art_DEM.generate_fractal_map">
<span class="sig-prename descclassname"><span class="pre">art_DEM.</span></span><span class="sig-name descname"><span class="pre">generate_fractal_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roughness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/art_DEM.html#generate_fractal_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#art_DEM.generate_fractal_map" title="Link to this definition"></a></dt>
<dd><p>Generates a square fractal map using the diamond-square algorithm, followed by Gaussian filtering.</p>
<p>The diamond-square algorithm is a fractal method used to generate random landscapes or textures.
The algorithm works by dividing the map into squares and diamonds, then randomly displacing the midpoint
of each to create roughness. Gaussian filtering is applied at the end to smooth out the map for a more
natural look.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – Determines the size of the map which will be <cite>(2^size) + 1</cite>.</p></li>
<li><p><strong>roughness</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The initial roughness factor for the diamond-square algorithm.</p></li>
<li><p><strong>sigma</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – Standard deviation for Gaussian filter, affecting the smoothness.</p></li>
<li><p><strong>seed</strong> (<em>(</em><em>optional</em><em>(</em><em>scalar</em><em>(</em><em>int</em><em>)</em><em>)</em><em>)</em>) – Optional seed for the random number generator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dem</strong> <em>(array_like(float))</em> - A 2D numpy array representing the fractal map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="art_DEM.generate_pathfile">
<span class="sig-prename descclassname"><span class="pre">art_DEM.</span></span><span class="sig-name descname"><span class="pre">generate_pathfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xllcorner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yllcorner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rough_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'art_path.txt'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/art_DEM.html#generate_pathfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#art_DEM.generate_pathfile" title="Link to this definition"></a></dt>
<dd><p>Generate a path file for artifical data sampling paths in an ASCII format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xllcorner</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The western x-coordinate of the lower left corner of the grid.</p></li>
<li><p><strong>yllcorner</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The southern y-coordinate of the lower left corner of the grid.</p></li>
<li><p><strong>Lx</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The length of the domain along the x-axis.</p></li>
<li><p><strong>rough_length</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The rough length of the path, minor changes will happen through this function, so length is eventually different to passed length.</p></li>
<li><p><strong>npath</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – Number of points in the path.</p></li>
<li><p><strong>seed</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – Optional seed for the random number generator.</p></li>
<li><p><strong>filename</strong> (<em>string</em>) – The name of the text file to write the path coordinates.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="art_DEM.write_dem_to_ascii">
<span class="sig-prename descclassname"><span class="pre">art_DEM.</span></span><span class="sig-name descname"><span class="pre">write_dem_to_ascii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrow</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xllcorner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yllcorner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'art_dem.ascii'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/art_DEM.html#write_dem_to_ascii"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#art_DEM.write_dem_to_ascii" title="Link to this definition"></a></dt>
<dd><p>Writes the digital elevation model (DEM) data to an ASCII file in grid format.</p>
<p>The ASCII format is a simple text-based format for storing raster data which is widely used in GIS
software. Each line contains the data for a single row of the grid, with values separated by spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem</strong> (<em>array_like</em><em>(</em><em>float</em><em>)</em>) – 2D array containing elevation data.</p></li>
<li><p><strong>ncol</strong> (<em>scalar</em><em>(</em><em>int</em><em>)</em>) – Number of columns in the DEM grid.</p></li>
<li><p><strong>nrow</strong> – Number of rows in the DEM grid.</p></li>
<li><p><strong>cellsize</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – Size of each cell in the grid.</p></li>
<li><p><strong>xllcorner</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The western x-coordinate of the lower left corner of the DEM grid.</p></li>
<li><p><strong>yllcorner</strong> (<em>scalar</em><em>(</em><em>float</em><em>)</em>) – The southern y-coordinate of the lower left corner of the DEM grid.</p></li>
<li><p><strong>filename</strong> (<em>string</em>) – The name of the ASCII file to write.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">1</a><span class="fn-bracket">]</span></span>
<p>These rough sizes are rounded off values, in case the DEM cut was not square, the value denotes the rounded length of the <strong>shortest</strong> side of the DEM.</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="etna.html" class="btn btn-neutral float-left" title="Case study: Mount Etna" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ref.html" class="btn btn-neutral float-right" title="References" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, A.E. Hendrickx.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<style type="text/css">
  .scrollToTop {
    text-align: center;
    font-weight: bold;
    position: fixed;
    bottom: 60px;
    right: 40px;
    display: none;
  }
</style>
<a href="#" class="scrollToTop">Scroll To Top</a>
<script type="text/javascript">
  $(document).ready(function () {
    //Check to see if the window is top if not then display button
    $(window).scroll(function () {
      if ($(this).scrollTop() > 200) {
        $(".scrollToTop").fadeIn();
      } else {
        $(".scrollToTop").fadeOut();
      }
    });

    //Click event to scroll to top
    $(".scrollToTop").click(function () {
      $("html, body").animate(
        {
          scrollTop: 0,
        },
        500,
      );
      return false;
    });
  });
</script>

<style>
  /* Sidebar header (and topbar for mobile) */
  .wy-side-nav-search,
  .wy-nav-top {
    background: #3ae23a;
  }
  /* Sidebar */
  .wy-nav-side {
    background: #0c3303;
  }
</style>


</body>
</html>